### Item32 谨慎地并用泛型和可变参数

> Varargs methods (Item 53) and generics were both added to the platform in Java 5, so you might expect them to interact gracefully; sadly, they do not. The purpose of varargs is to allow clients to pass a variable number of arguments to a method, but it is a *leaky abstraction*: when you invoke a varargs method, an array is created to hold the varargs parameters; that array, which should be an implementation detail, is visible. As a consequence, you get confusing compiler warnings when varargs parameters have generic or parameterized types.

可变参数方法和泛型是在Java5中一起假如到Java平台中来的，因此你可能会期望它俩能很好的互相作用；遗憾的是，他们不能。设计可变参数的目的是允许客户端给一个方法传递可变数量的参数，但是它是一个“技术露底”：当你在调用一个可变参数方法的时候，会创建一个数组来持有这些可变参数；而这个数组，本应该是实现细节，却是可见的。因此，当你的可变参数中有泛型或者参数化类型的时候，你可能会得到一个莫名其妙的编译器警告。

> Recall from Item 28 that a non-reifiable type is one whose runtime representation has less information than its compile-time representation, and that nearly all generic and parameterized types are non-reifiable. If a method declares its varargs parameter to be of a non-reifiable type, the compiler generates a warning on the declaration. If the method is invoked on varargs parameters whose inferred type is non-reifiable, the compiler generates a warning on the invocation too. The warnings look something like this:

回顾一下Item28里说的，不可具体化类型就是一个运行时信息比编译时少的类型，而且基本所有的泛型和参数化类型都是不可具体化的。如果一个方法声明的可变参数是不可具体化的类型，编译器就会在这个声明上生成一个警告。如果这个方法被调用的时候，其可变参数的推导类型是不可具体画的，编译器也会在这个调用上生成一个警告。这个警告大概长这样：

```java
warning: [unchecked] Possible heap pollution from
       parameterized vararg type List<String>
```

> *Heap pollution* occurs when a variable of a parameterized type refers to an object that is not of that type [JLS, 4.12.2]. It can cause the compiler’s automatically generated casts to fail, violating the fundamental guarantee of the generic type system.

堆泄露会在一个参数化类型变量指向一个不是这个类型的对象的时候出现 [JLS, 4.12.2]。它会导致编译器自动生成的转换失败，从而破坏了泛型系统的基本保证。

> For example, consider this method, which is a thinly disguised variant of the code fragment on page 127:

比如，下面这个方法，是Item28里的代码片段稍加修改得到的：

```java
// Mixing generics and varargs can violate type safety! 
static void dangerous(List<String>... stringLists) {
	List<Integer> intList = List.of(42);
	Object[] objects = stringLists;
	objects[0] = intList; // Heap pollution 
  String s = stringLists[0].get(0); // ClassCastException
}
```

> This method has no visible casts yet throws a ClassCastException when invoked with one or more arguments. Its last line has an invisible cast that is generated by the compiler. This cast fails, demonstrating that type safety has been compromised, and **it is unsafe to store a value in a generic varargs array parameter.**

这个方法没有显示的类型转化，但是在使用一个或者多个参数进行调用的时候，会生成ClassCastException。代码的最后一行里有一个编译器生成的不可见的类型转换，这个转换失败了，也就意味着类型安全收到了威胁，**所以将值保存在泛型可变数组参数里时不安全的。**

> This example raises an interesting question: Why is it even legal to declare a method with a generic varargs parameter, when it is illegal to create a generic array explicitly? In other words, why does the method shown previously generate only a warning, while the code fragment on page 127 generates an error? The answer is that methods with varargs parameters of generic or parameterized types can be very useful in practice, so the language designers opted to live with this inconsistency. In fact, the Java libraries export several such methods, including Arrays.asList(T... a), Collections.addAll(Collection<? super T> c, T... elements), and EnumSet.of(E first, E... rest). Unlike the dangerous method shown earlier, these library methods are typesafe.

那么，一个有趣的问题就来了，为什么显式的创建一个泛型数组是非法的，而声明一个有泛型的可变参数却是合法的呢？换句话说，就是，为什么前面这个方法只是生成了一个warning，而Item28里的代码就或生成一个error呢？答案是因为泛型或者参数化类型的可变参数方法，在实际应用中实在是太有用了。所以语言设计者，选择了就这么前后矛盾着。事实上，在Java类库中有很多这样的方法，包括Arrays.asList(T... a)，Collections.addAll(Collection<? super T> c, T... elements)，和 EnumSet.of(E first, E... rest)。和前面这个dangerous方法不一样的是，这些类库方法都是类型安全的。

> Prior to Java 7, there was nothing the author of a method with a generic varargs parameter could do about the warnings at the call sites. This made these APIs unpleasant to use. Users had to put up with the warnings or, preferably, to eliminate them with @SuppressWarnings("unchecked") annotations at every call site (Item 27). This was tedious, harmed readability, and hid warnings that flagged real issues.



























